\chapter{結論}

\section{本研究の総括}
本研究では，先行研究で提案されたSBCマルチディスプレイシステムにおける動作時のパフォーマンスとスケーラビリティの向上を目的とした．
提案では，OS仮想化技術を用いてヘッドノード内のフレーム圧縮処理を独立したプロセスとして並列化するとともに，コンテナ間でのフレームデータの受け渡しを共有メモリで行う機能を実装した．
提案手法におけるヘッドノードの機能は，画像フレームの分割を行う分割コンテナ，画像フレームの圧縮と送信を行う圧縮コンテナ，ディスプレイノード群の同期制御を行う同期制御コンテナの3種類のコンテナとして設計した．
圧縮コンテナはディスプレイ数と同数を動作させ，ヘッドノード内の単一スレッドで行われていたフレームの圧縮処理を複数の圧縮コンテナで行うことで1フレームあたりに要する処理時間を短縮している．
また，分割コンテナと圧縮コンテナの間で必要となる画像フレームの受け渡し処理にはLinuxの機能である共有メモリ(SYSTEM V IPC)を使用し，カーネルの機能を使用せずに，プロセス間のデータ受け渡しを可能にする実装を行った．
共有メモリを利用することで，フレームデータ受け渡しにかかるオーバーヘッドを抑えることができた．



本研究の評価では，提案手法の効果を検証するために，提案手法を用いて実装したヘッドノード上でのフレーム処理時間を計測し，既存システムのヘッドノード内でのフレーム処理時間との比較を行った．
実験では4面構成および9面構成のマルチディスプレイを構築することを想定し，ヘッドノード内で1つの分割コンテナと，ディスプレイ数と同じ数の圧縮コンテナを動作させた．
結果，既存手法のヘッドノードではフレーム処理に４面構成の場合は49ms，9面構成の場合は117msを要していたのに対し，提案手法ではそれぞれ21ms，52msとなっており，提案手法によるフレーム処理並列化の効果によって処理時間が短縮されている事が確認できた．
また，ディスプレイ数を増加させた場合においてはフレームの拡大・分割に要する時間は既存手法と同様に増加しているものの，圧縮処理では既存手法と比較して提案手法では処理時間の増加は小さくなっており，システムのスケーラビリティが改善されていることも確認できた．

\section{将来課題}
今後，本研究の研究成果をさらに発展させるためには，以下の2点が将来課題となる．
\begin{itemize}
    \item 提案手法を用いたマルチディスプレイシステムにおける同期制御処理の実装
    \item 圧縮パラメータ変更処理の実装
\end{itemize}

\clearpage

\subsection*{提案手法を用いたMDにおける同期制御処理の実装}
本研究の実装範囲はヘッドノード内のフレーム処理プロセスのみにとどまっており，共有メモリから受け取ったフレームデータの描画処理までは実装できていない．
ディスプレイ上に動画を表示する場合にはヘッドノードとディスプレイノードの間での同期制御処理が不可欠である．
そのため，提案手法を用いたシステム内で同期制御処理を行う機能の実装が将来課題としてあげられる．

\subsection*{圧縮パラメータ変更処理の実装}
既存手法を用いたマルチディスプレイシステムでは，各ディスプレイノード上のフレーム受信・展開処理がボトルネック化するのを防ぐために，同期メッセージを利用した
JPEGパラメータ(YCbCr サンプル比・品質係数) のフィードバック制御機能が実装されている．
本研究での提案手法を用いたヘッドノードでは，複数のコンテナでフレーム圧縮処理を行うため，1つのプロセス内でフレームの圧縮を行っていた既存手法と比較してフレームレートを一定に保つためのフィードバック機能の実装は複雑になると考えられる．
そのため，複数のコンテナで行われるフレームの圧縮処理を統合的に管理し，制御できるような手法の考案が必要であると考えられる．